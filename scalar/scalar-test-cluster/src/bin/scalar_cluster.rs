// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

use anyhow::Result;
use axum::{
    extract::Path,
    response::IntoResponse,
    routing::{get, post},
    Extension, Json, Router,
};
use clap::Parser;
use http::{Method, StatusCode};
use scalar_test_cluster::{Env, LocalClusterConfig, Cluster, LocalNewCluster};
use tokio::time::Sleep;
use std::{net::SocketAddr, sync::Arc, time, thread};
use tower::ServiceBuilder;
use tracing::info;
use uuid::Uuid;

/// Start a Sui validator and fullnode for easy testing.
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {
    /// Config directory that will be used to store network config, node db, keystore
    /// sui genesis -f --with-faucet generates a genesis config that can be used to start this process.
    /// Example: sui-test-validator --config-dir ~/.sui/sui_config
    /// We can use any config dir that is generated by the sui genesis.
    #[clap(short, long)]
    config_dir: Option<std::path::PathBuf>,

    /// Number of node in test cluster
    #[clap(long, default_value = "4")]
    cluster_size: Option<usize>,

    /// Port to start the Fullnode RPC server on
    #[clap(long, default_value = "5000")]
    consensus_grpc_port: Option<u16>,

    /// Port to start the Fullnode RPC server on
    #[clap(long, default_value = "9000")]
    fullnode_rpc_port: u16,

    /// Port to start the Sui faucet on
    #[clap(long, default_value = "9123")]
    faucet_port: u16,

    /// Host to start the GraphQl server on
    #[clap(long, default_value = "127.0.0.1")]
    graphql_host: String,

    /// Port to start the GraphQl server on
    /// Explicitly setting this enables the server
    #[clap(long)]
    graphql_port: Option<u16>,

    /// Port to start the Indexer RPC server on
    #[clap(long, default_value = "9124")]
    indexer_rpc_port: u16,

    /// Port for the Indexer Postgres DB
    /// 5432 is the default port for postgres on Mac
    #[clap(long, default_value = "5432")]
    pg_port: u16,

    /// Hostname for the Indexer Postgres DB
    #[clap(long, default_value = "localhost")]
    pg_host: String,

    /// DB name for the Indexer Postgres DB
    #[clap(long, default_value = "sui_indexer")]
    pg_db_name: String,

    /// DB username for the Indexer Postgres DB
    #[clap(long, default_value = "postgres")]
    pg_user: String,

    /// DB password for the Indexer Postgres DB
    #[clap(long, default_value = "postgrespw")]
    pg_password: String,

    /// The duration for epochs (defaults to one minute)
    #[clap(long, default_value = "60000")]
    epoch_duration_ms: u64,

    /// if we should run indexer
    #[clap(long)]
    pub with_indexer: bool,

    /// TODO(gegao): remove this after indexer migration is complete.
    #[clap(long)]
    pub use_indexer_experimental_methods: bool,

    /// If we should use the new version of the indexer
    #[clap(long)]
    pub use_indexer_v2: bool,


}

#[tokio::main]
async fn main() -> Result<()> {
    let (_guard, _filter_handle) = telemetry_subscribers::TelemetryConfig::new()
        .with_env()
        .init();

    let args = Args::parse();
    let Args {
        config_dir,
        cluster_size,
        consensus_grpc_port,
        fullnode_rpc_port,
        graphql_host,
        graphql_port,
        indexer_rpc_port,
        pg_port,
        pg_host,
        pg_db_name,
        pg_user,
        pg_password,
        epoch_duration_ms,
        faucet_port,
        with_indexer,
        use_indexer_experimental_methods,
        use_indexer_v2,
    } = args;

    // We don't pass epoch duration if we have a genesis config.
    let epoch_duration_ms = if config_dir.is_some() {
        None
    } else {
        Some(epoch_duration_ms)
    };

    if graphql_port.is_none() {
        println!("Graphql port not provided. Graphql service will not run.")
    }
    if !with_indexer {
        println!("`with_indexer` flag unset. Indexer service will not run.")
    } else if !use_indexer_v2 {
        println!("`with_indexer` flag unset. Indexer service will run unmaintained indexer.")
    }
    let cluster_config = LocalClusterConfig {
        env: Env::NewLocal,
        consensus_grpc_port,
        fullnode_address: Some(format!("127.0.0.1:{}", fullnode_rpc_port)),
        indexer_address: with_indexer.then_some(format!("127.0.0.1:{}", indexer_rpc_port)),
        pg_address: Some(format!(
            "postgres://{pg_user}:{pg_password}@{pg_host}:{pg_port}/{pg_db_name}"
        )),
        faucet_address: Some(format!("127.0.0.1:{}", faucet_port)),
        epoch_duration_ms,
        use_indexer_experimental_methods,
        config_dir,
        cluster_size,
        graphql_address: graphql_port.map(|p| format!("{}:{}", graphql_host, p)),
        use_indexer_v2,
    };
    info!(
        "Starting local validator cluster with config: {:#?}",
        &cluster_config
    );
    let local_cluster = LocalNewCluster::start(&cluster_config).await?;
    let swarm = local_cluster.swarm();
    // println!("Fullnode RPC URL: {}", cluster.fullnode_url());

    // if with_indexer {
    //     println!(
    //         "Indexer RPC URL: {}",
    //         cluster.indexer_url().clone().unwrap_or_default()
    //     );
    // }

    //start_faucet(&cluster, faucet_port).await?;
    // Keep main thread alive instead of start_faucet
    let one_minute = time::Duration::from_secs(60);
    loop {
        thread::sleep(one_minute);
    }
    //Ok(())
}
